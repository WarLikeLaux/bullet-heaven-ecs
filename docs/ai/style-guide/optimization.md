# ⚡ Оптимизация

Стек **TS + Three.js + ECS** держит **5,000–10,000 юнитов** при 60 FPS, если соблюдать три правила.

## 1. Draw Calls → InstancedMesh

| Проблема                                     | Решение                                         |
| -------------------------------------------- | ----------------------------------------------- |
| `new Mesh()` на каждого врага = N draw calls | `InstancedMesh` — 1 draw call на все экземпляры |

- Создаём **одну** геометрию и материал.
- Обновляем матрицу позиций через `setMatrixAt()`.
- 5000 врагов = 1 draw call.

## 2. GC Pressure → Object Pool

| Проблема                         | Решение                              |
| -------------------------------- | ------------------------------------ |
| `new Bullet()` в loop = GC фризы | Пул объектов — 0 аллокаций в runtime |

- Массив из N объектов создаётся на старте (скрытых).
- Спавн: `visible = true`, берём из пула.
- Смерть: `visible = false`, возвращаем в пул.
- Аналог пула коннектов к БД.

## 3. Коллизии O(N²) → Spatial Hash

| Проблема                                   | Решение                       |
| ------------------------------------------ | ----------------------------- |
| 1000 пуль × 1000 врагов = 1M проверок/кадр | Пространственная сетка — O(N) |

- Карта делится на клетки (например, 10×10).
- Проверяем коллизии только внутри клетки.
- Библиотеки: `RBush`, `Rapier` (WebAssembly).

## Правила для hot path (`tick()`)

| Запрещено ❌                 | Правильно ✅                        |
| ---------------------------- | ----------------------------------- |
| `new Vector3()` в цикле      | `const V = new Vector3()` вне цикла |
| `new Mesh()` при спавне      | `InstancedMesh` + `setMatrixAt()`   |
| `array.filter()` каждый кадр | ECS query (`world.with(...)`)       |
| `scene.add()` / `remove()`   | `visible = true/false`              |

## Когда применять

| Этап           | Действие                     |
| -------------- | ---------------------------- |
| < 200 юнитов   | Не оптимизируй               |
| 200–500 юнитов | InstancedMesh для врагов     |
| 500+ юнитов    | + Object Pool + Spatial Hash |

## См. также

- `docs/ai/contract.md` — запреты на аллокации в loop
